// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateHeightData

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> HeightMap;
RWTexture2D<float4> ResultMap;

int mapWidth = 8192;
int mapHeight = 8192;
float heightMultiplier = 5;
float worldRadius = 600;
const float PI = 3.14159;

float3 coordinateToPoint(float latitude, float longitude)
{
    latitude = radians(latitude);
    longitude = radians(longitude);
    // float x = cos(latitude) * cos(longitude);
    // float y = sin(latitude);
    // float z = cos(latitude) * sin(longitude);
    
    float y = sin(latitude);
    float r = cos(latitude);
    float x = sin(longitude) * r;
    float z = -cos(longitude) * r;

    return float3(x, y, z);
}

float3 calculateWorldPoint(int2 texCoord)
{
    texCoord.x = (texCoord.x + mapWidth) % mapWidth;
    texCoord.y = (texCoord.y + mapHeight) % mapHeight;
    float2 uv = texCoord / float2(mapWidth - 1, mapHeight - 1);
    float longitude = -180.0 + uv * 360.0;
    float latitude = uv * 90.0;
    float3 spherePoint = coordinateToPoint(latitude,  longitude);

    float height01 = HeightMap[texCoord];
    float worldHeight = (height01 == 0) ? 0 : worldRadius + height01 * heightMultiplier;
    return spherePoint * worldHeight;
}

[numthreads(8,8,1)]
void CalculateHeightData (uint3 id : SV_DispatchThreadID)
{
    float3 posNorth = calculateWorldPoint(id.xy + int2(0, 1));
    float3 posSouth = calculateWorldPoint(id.xy + int2(0, -1));
    float3 posEast = calculateWorldPoint(id.xy + int2(1, 0));
    float3 posWest = calculateWorldPoint(id.xy + int2(-1, 0));

    float3 dirNorth = normalize(posNorth - posSouth);
    float3 dirEast = normalize(posEast - posWest);
    float3 normalVector = normalize(cross(dirNorth, dirEast));

    float height01 = HeightMap[id.xy];
    ResultMap[id.xy] = float4(normalVector.xyz, height01);
}
